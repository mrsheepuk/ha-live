package uk.co.mrsheep.halive.services

import com.google.firebase.ai.type.FunctionCallPart
import com.google.firebase.ai.type.FunctionResponsePart

/**
 * Interface for executing Home Assistant tools within a Gemini Live conversation.
 *
 * This interface defines the contract for handling tool calls initiated by the Gemini Live API.
 * It enables dependency inversion by allowing different implementations for various scenarios
 * while maintaining a consistent API contract.
 *
 * ## Purpose
 * Acts as an abstraction layer between the Gemini Live API (which generates function calls) and
 * the actual Home Assistant backend (which executes those calls). This decoupling enables flexible
 * testing, mocking, and alternative implementations.
 *
 * ## Benefits
 * - **Testability**: Easy to mock for unit tests without invoking real Home Assistant APIs
 * - **Flexibility**: Support multiple implementations (real, simulated, logging, safe-mode)
 * - **Separation of Concerns**: Isolates tool execution logic from conversation management
 * - **Dependency Inversion**: Depend on abstractions, not concrete implementations
 *
 * ## Use Cases
 * - **Production**: Execute real tool calls via MCP to Home Assistant
 * - **Testing**: Mock implementation for unit tests and behavior verification
 * - **Simulation**: Test-friendly implementation that simulates tool results without side effects
 * - **Logging**: Wrapper implementation that logs all tool executions for debugging
 * - **Safe Mode**: Implementation with additional validation and error handling
 *
 * ## Implementation Example
 * ```kotlin
 * class GeminiMCPToolExecutor(private val mcpClient: McpClientManager) : ToolExecutor {
 *     override suspend fun executeTool(call: FunctionCallPart): FunctionResponsePart {
 *         // Transform FunctionCallPart to MCP call
 *         // Execute via mcpClient
 *         // Transform result back to FunctionResponsePart
 *     }
 * }
 * ```
 *
 * ## Why This Interface Exists
 * The Dependency Inversion Principle states that high-level modules (e.g., MainViewModel) should
 * not depend on low-level modules (e.g., McpClientManager). Instead, both should depend on
 * abstractions (ToolExecutor). This allows:
 * - Swapping implementations without changing calling code
 * - Testing without external dependencies
 * - Future enhancements (e.g., rate limiting, retry logic) as transparent wrappers
 */
interface ToolExecutor {
    /**
     * Executes a Home Assistant tool call and returns the result.
     *
     * This is a suspending function that performs asynchronous execution of a tool call
     * initiated by the Gemini Live API. The implementation handles:
     * - Transforming Gemini function calls to Home Assistant tool format
     * - Communicating with Home Assistant (via MCP or other mechanisms)
     * - Converting Home Assistant results back to Gemini function response format
     *
     * @param call The function call part generated by Gemini Live API containing:
     *             - Function name
     *             - Arguments as a JSON object
     *
     * @return A [FunctionResponsePart] containing:
     *         - The result of tool execution (as a JSON-serializable value)
     *         - Or an error response if execution failed
     *
     * @throws Exception Implementations may throw exceptions for unrecoverable errors.
     *         Callers should handle exceptions and convert them to appropriate error responses.
     *
     * @see FunctionCallPart
     * @see FunctionResponsePart
     */
    suspend fun executeTool(call: FunctionCallPart): FunctionResponsePart
}
