package uk.co.mrsheep.halive.services

import android.util.Log
import com.google.firebase.ai.type.FunctionCallPart
import com.google.firebase.ai.type.FunctionResponsePart
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put

/**
 * Mock implementation of [ToolExecutor] for safe testing without affecting real Home Assistant state.
 *
 * ## Purpose
 * This implementation provides a test-friendly alternative to [GeminiMCPToolExecutor] that allows
 * developers to test conversation flows, prompt effectiveness, and UI behavior without making
 * actual calls to Home Assistant. All tool executions return canned success responses.
 *
 * ## Behavior
 * - Returns a simulated success response for every tool call
 * - Response format: `{"result": "Mock execution of [toolName] with args: [args]"}`
 * - Includes optional tracking of which tools were called (for debugging and verification)
 * - Logs all tool calls to Logcat for debugging
 *
 * ## Use Cases
 * - **Profile Testing**: Validate profiles and system prompts without a live Home Assistant instance
 * - **Conversation Flow Testing**: Test how Gemini responds to different conversation patterns
 * - **Prompt Development**: Iterate on system prompts and personality settings safely
 * - **Feature Testing**: Test UI features and conversation mechanics without side effects
 * - **Demo Mode**: Demonstrate the app without requiring a real Home Assistant setup
 *
 * ## Safety Characteristics
 * - Never makes actual calls to Home Assistant via MCP or REST API
 * - Never invokes any real service calls or automations
 * - Never modifies any state on the Home Assistant instance
 * - All responses are purely simulated and safe to use in any environment
 *
 * ## Example Usage
 * ```kotlin
 * val mockExecutor = MockToolExecutor()
 * val call = FunctionCallPart(
 *     name = "turn_on",
 *     id = "call_123",
 *     args = mapOf("entity_id" to "light.living_room")
 * )
 * val response = mockExecutor.executeTool(call)
 * // response contains: {"result": "Mock execution of turn_on with args: {entity_id=light.living_room}"}
 *
 * // Check what tools were called
 * println(MockToolExecutor.getCalledTools())  // [turn_on]
 * ```
 */
class MockToolExecutor : ToolExecutor {
    /**
     * Executes a tool call with a mock response.
     *
     * Always returns a simulated success response without making any actual calls to Home Assistant.
     * Logs the tool call and tracks it for debugging purposes.
     *
     * @param call The function call part generated by Gemini Live API
     * @return A [FunctionResponsePart] with a simulated success response containing the tool name and arguments
     */
    override suspend fun executeTool(call: FunctionCallPart): FunctionResponsePart {
        Log.d(TAG, "Mock execution of tool: ${call.name} with args: ${call.args}")

        // Track the tool call for debugging
        synchronized(calledTools) {
            calledTools.add(call.name)
        }

        // Create a mock response that simulates successful execution
        val mockResult = "Mock execution of ${call.name} with args: ${call.args}"
        Log.d(TAG, "Mock response: $mockResult")

        return FunctionResponsePart(
            name = call.name,
            id = call.id,
            response = buildJsonObject {
                put("result", JsonPrimitive(mockResult))
            }
        )
    }

    companion object {
        private const val TAG = "MockToolExecutor"

        /**
         * List of tools that have been called via this executor during the current session.
         * Used for debugging and verifying which tools the Gemini model attempted to use.
         */
        private val calledTools = mutableListOf<String>()

        /**
         * Returns a copy of the list of tools that have been called via mock execution.
         *
         * @return A list of tool names in the order they were called
         */
        fun getCalledTools(): List<String> {
            return synchronized(calledTools) {
                calledTools.toList()
            }
        }

        /**
         * Clears the call history. Useful for resetting between test cases.
         */
        fun clearCallHistory() {
            synchronized(calledTools) {
                calledTools.clear()
            }
        }

        /**
         * Returns the number of tools that have been called via mock execution.
         *
         * @return Count of tool invocations
         */
        fun getCallCount(): Int {
            return synchronized(calledTools) {
                calledTools.size
            }
        }

        /**
         * Checks if a specific tool was called.
         *
         * @param toolName The name of the tool to check for
         * @return true if the tool was called at least once, false otherwise
         */
        fun wasToolCalled(toolName: String): Boolean {
            return synchronized(calledTools) {
                calledTools.contains(toolName)
            }
        }
    }
}
