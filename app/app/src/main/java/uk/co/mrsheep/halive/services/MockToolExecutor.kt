package uk.co.mrsheep.halive.services

import android.util.Log
import com.google.firebase.ai.type.FunctionCallPart
import com.google.firebase.ai.type.FunctionResponsePart
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put

/**
 * Mock implementation of [ToolExecutor] for safe testing without affecting real Home Assistant state.
 *
 * ## Purpose
 * This implementation provides a test-friendly alternative to [GeminiMCPToolExecutor] that allows
 * developers to test conversation flows, prompt effectiveness, and UI behavior without making
 * actual calls to Home Assistant. All tool executions return canned success responses.
 *
 * ## Behavior
 * - Returns a simulated success response for every tool call
 * - Response format: `{"result": "Mock execution of [toolName] with args: [args]"}`
 * - Includes optional tracking of which tools were called (for debugging and verification)
 * - Logs all tool calls to Logcat for debugging
 *
 * ## Pass-Through for Read-Only Tools
 * If a real ToolExecutor is provided, read-only tools (GetLiveContext, GetDateTime) are
 * passed through to the real Home Assistant for accurate, current data. This provides:
 * - Realistic testing with actual HA state
 * - Better validation of prompts and conversation flows
 * - Graceful fallback to mock responses if real execution fails
 *
 * All other tools (state-modifying) are always mocked for safety.
 *
 * ## Use Cases
 * - **Profile Testing**: Validate profiles and system prompts without a live Home Assistant instance
 * - **Conversation Flow Testing**: Test how Gemini responds to different conversation patterns
 * - **Prompt Development**: Iterate on system prompts and personality settings safely
 * - **Feature Testing**: Test UI features and conversation mechanics without side effects
 * - **Demo Mode**: Demonstrate the app without requiring a real Home Assistant setup
 *
 * ## Safety Characteristics
 * - Never makes actual calls to Home Assistant via MCP or REST API
 * - Never invokes any real service calls or automations
 * - Never modifies any state on the Home Assistant instance
 * - All responses are purely simulated and safe to use in any environment
 *
 * ## Example Usage
 * ```kotlin
 * val mockExecutor = MockToolExecutor()
 * val call = FunctionCallPart(
 *     name = "turn_on",
 *     id = "call_123",
 *     args = mapOf("entity_id" to "light.living_room")
 * )
 * val response = mockExecutor.executeTool(call)
 * // response contains: {"result": "Mock execution of turn_on with args: {entity_id=light.living_room}"}
 *
 * // Check what tools were called
 * println(MockToolExecutor.getCalledTools())  // [turn_on]
 * ```
 */
class MockToolExecutor(
    private val realExecutor: ToolExecutor? = null
) : ToolExecutor {
    /**
     * Executes a tool call with a mock response or passes through to real executor for read-only tools.
     *
     * Logs the tool call and tracks it for debugging purposes.
     *
     * @param call The function call part generated by Gemini Live API
     * @return A [FunctionResponsePart] with either a real response (for pass-through tools) or a simulated success response
     */
    override suspend fun executeTool(call: FunctionCallPart): FunctionResponsePart {
        // Try to pass through read-only tools to real executor for realistic data
        if (call.name in PASSTHROUGH_TOOLS && realExecutor != null) {
            return try {
                Log.d(TAG, "Passing through ${call.name} to real executor for realistic data")
                val result = realExecutor.executeTool(call)

                // Still track the call in mock history
                synchronized(calledTools) {
                    calledTools.add(call.name)
                }

                result
            } catch (e: Exception) {
                Log.w(TAG, "Real executor failed for ${call.name}, falling back to mock: ${e.message}")
                // Fall through to mock response
                createMockResponse(call)
            }
        }

        // All other tools get mocked
        return createMockResponse(call)
    }

    /**
     * Creates a mock response that simulates successful tool execution.
     *
     * @param call The function call part to create a response for
     * @return A [FunctionResponsePart] with a simulated success response
     */
    private fun createMockResponse(call: FunctionCallPart): FunctionResponsePart {
        Log.d(TAG, "Mock execution of tool: ${call.name} with args: ${call.args}")

        // Track the tool call for debugging
        synchronized(calledTools) {
            calledTools.add(call.name)
        }

        // Create a mock response that simulates successful execution
        val mockResult = "Mock execution of ${call.name} with args: ${call.args}"
        Log.d(TAG, "Mock response: $mockResult")

        return FunctionResponsePart(
            name = call.name,
            id = call.id,
            response = buildJsonObject {
                put("result", JsonPrimitive(mockResult))
            }
        )
    }

    companion object {
        private const val TAG = "MockToolExecutor"

        /**
         * Read-only tools that are safe to pass through to real Home Assistant.
         * These tools don't modify state and provide valuable context during testing.
         */
        private val PASSTHROUGH_TOOLS = setOf(
            "GetLiveContext",  // Current HA state overview
            "GetDateTime"      // Current date/time
        )

        /**
         * List of tools that have been called via this executor during the current session.
         * Used for debugging and verifying which tools the Gemini model attempted to use.
         */
        private val calledTools = mutableListOf<String>()

        /**
         * Returns a copy of the list of tools that have been called via mock execution.
         *
         * @return A list of tool names in the order they were called
         */
        fun getCalledTools(): List<String> {
            return synchronized(calledTools) {
                calledTools.toList()
            }
        }

        /**
         * Clears the call history. Useful for resetting between test cases.
         */
        fun clearCallHistory() {
            synchronized(calledTools) {
                calledTools.clear()
            }
        }

        /**
         * Returns the number of tools that have been called via mock execution.
         *
         * @return Count of tool invocations
         */
        fun getCallCount(): Int {
            return synchronized(calledTools) {
                calledTools.size
            }
        }

        /**
         * Checks if a specific tool was called.
         *
         * @param toolName The name of the tool to check for
         * @return true if the tool was called at least once, false otherwise
         */
        fun wasToolCalled(toolName: String): Boolean {
            return synchronized(calledTools) {
                calledTools.contains(toolName)
            }
        }
    }
}
